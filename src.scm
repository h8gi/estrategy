(use symbol-utils)
(define *quit* #f)
(define *return* #f)
(define *default-evaluation-strategy* 'value)
(define (meta-error . args)
  (printf "Error: ~a\n" (car args))
  (for-each (lambda (x) (printf "~a " x)) (cdr args))
  (newline)
  (*return* 'return))
(define *eval-table* (make-hash-table))
(define (put op type proc)
  (hash-table-set! *eval-table* (list op type) proc))
(define (get op type)
  (hash-table-ref/default *eval-table* (list op type) #f))

;;; eval データ主導流
;;; lazy 修正
(define (meta-eval exp env)
  (cond ((null? exp) (meta-error "illegal non-atomic object: " exp))
        ((self-evaluating? exp) exp)
        ((variable? exp)
         (lookup-variable-value exp env)) ;変数は
        (else
         (if (get 'eval (operator exp))
             ((get 'eval (operator exp)) exp env)
             (if (application? exp)
                 (meta-apply (actual-value (operator exp) env) ; (meta-eval (operator exp) env)
                             (operands exp) ; (list-of-values (operands exp) env)
                             env))))))
;;; サンクから値を引き出す
(define (actual-value exp env)
  (force-it (meta-eval exp env)))

;;; 関数適用
(define (meta-apply procedure arguments env)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure
          (list-of-arg-values arguments env))) ; 基本手続きは引数に対してストリクト
        ((compound-procedure? procedure)
         (eval-sequence 
          (procedure-body procedure)          
          (extend-environment 
           (clean-parameters (procedure-parameters procedure))
           (list-of-selective-delayed-args arguments
                                           (procedure-parameters procedure)
                                           env) ; 合成手続きは遅延引数
           (procedure-environment procedure))))
        (else
         (meta-error
          "Unknown procedure type -- META-APPLY" procedure))))
;;; 引数から値の引き出し
(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps) env) ;forceしている
            (list-of-arg-values (rest-operands exps) env))))
;;; 遅延させる
(define (list-of-selective-delayed-args exps params env)
  (define (value? exp)    
    (eq? 'value (cadr exp)))
  (define (name? exp)
    (eq? 'name (cadr exp)))
  (define (need? exp)
    (eq? 'need (cadr exp)))
  (if (no-operands? exps)
      '()
      (let ((o (first-operand exps))
            (p (first-operand params)))
        (cons (if (pair? p)
                  (cond  ((name? p)  (delay-it o env))
                         ((need? p)  (memo-delay-it o env))
                         (else (actual-value o env)))
                  (cond ((eq? *default-evaluation-strategy* 'name) (delay-it o env))
                        ((eq? *default-evaluation-strategy* 'need) (memo-delay-it o env))
                        (else
                         (actual-value o env))))
              (list-of-selective-delayed-args (rest-operands exps)
                                              (rest-operands params)
                                              env)))))
;;; サンクの表現
;;; delay と force
;;; actual-valueのなかでforce-itが呼ばれるので再帰的に値呼び出し
;; (define (force-it obj)
;;   (if (thunk? obj)
;;       (actual-value (thunk-exp obj) (thunk-env obj))
;;       obj))
(define (delay-it exp env)
  (list 'thunk exp env))
(define (thunk? obj)
  (tagged-list? obj 'thunk))
(define (memo-delay-it exp env)
  (list 'memo-thunk exp env))
(define (memo-thunk? obj)
  (tagged-list? obj 'memo-thunk))
(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (caddr thunk))

(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))
(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))
(define (force-it obj)
  (cond ((thunk? obj)
         (actual-value (thunk-exp obj)
                       (thunk-env obj)))
        ((memo-thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result) ;expを値で置き換え
           (set-cdr! (cdr obj) '())    ;不要なenvを忘れる
           result))        
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))

;;; 自己評価
(define (self-evaluating? exp)
  (cond ((number? exp) #t)
        ((string? exp) #t)
        ((boolean? exp) #t)
        (else #f)))
;;; 変数
(define (variable? exp)
  (symbol? exp))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; PROCEDURE 手続き
;;; 問題 4.16 b
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
(define (definition? exp)
  (tagged-list? exp 'define))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)        ; 仮パラメタ
                   (cddr exp))))      ; 本体
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))  
(define (scan-out-defines body-g)
  (define (inner body new-binds new-sets new-bodys)
    (cond ((null? body) (if (null? new-binds)
                            body-g
                            `((let ,(reverse new-binds)
                                ,@(reverse new-sets)
                                ,@(reverse new-bodys)))))
          ((definition? (car body))
           (inner (cdr body)
                  (cons (list (definition-variable (car body))
                              ''*unassigned*) new-binds)
                  (cons (list 'set! (definition-variable (car body))
                              (definition-value (car body))) new-sets)
                  new-bodys))
          (else (inner (cdr body) new-binds new-sets (cons (car body) new-bodys)))))
  (inner body-g '() '() '()))

(define (make-procedure parameters body env)
  (list 'procedure parameters (scan-out-defines body) env))
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (clean-parameters params)
  (map (lambda (x)
         (if (pair? x) (car x)
             x))
       params))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures  
  (list
   (list 'car car)
   (list 'apply apply)
   (list 'cdr cdr)
   (list 'cons cons)
   (list 'append append)      
   (list 'eq? eq?)
   (list 'eqv? eqv?)
   (list 'equal? equal?)
   (list 'pair? pair?)
   (list 'list? list?)
   (list 'symbol? symbol?)
   (list 'null? null?)
   (list 'list list) 
   (list 'atom? atom?)
   (list 'number? number?)
   (list 'integer? integer?)
   (list 'procedure? procedure?)        
   (list 'not not)
   (list 'memq memq)
   (list 'memv memv)
   (list 'member member)
   (list 'zero? zero?)
   (list '> >)
   (list '< <)
   (list '>= >=)
   (list '<= <=)
   (list '= =)        
   (list '+ +)
   (list '- -)
   (list '* *)
   (list '/ /)
   (list 'display display)
   (list 'newline newline)
   (list 'printf printf)
   (list 'eval eval)
   ))
(define (primitive-procedure-names)
  (map car
       primitive-procedures))
(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

;;; APPLICATION 手続き作用

(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
(define apply-in-underlying-scheme ##sys#apply)
(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;;; 問題 4.1
;;; 関数適用の際, operandsを評価 左 => 右

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let ((val (meta-eval (first-operand exps) env)))
        (cons val
              (list-of-values (rest-operands exps) env)))))
;;; tagged-list?

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;;; beginとかいろいろ

(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (meta-eval (first-exp exps) env))
        (else (meta-eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 環境に対する操作
;;; ***環境はフレームの並び(list)**
;;; (lookup-variable-value <var> <env>)
;;;   <env>の中で<var>に束縛された値を返すか、未束縛ならerror
;;; (extend-environment <variables> <values> <base-env>)
;;;   外側の環境 <base-env>、リスト<variables>の記号が<values>の対応する要素に束縛された
;;;   新しいフレームからなる<env>を返す
;;; (define-variable! <var> <value> <env>)
;;;   <env>の最初のフレームに変数<var>と値<value>を対応付ける新しい束縛を追加する
;;; (set-variable-value! <var> <value> <env>)
;;;   <env>の変数<var>の束縛を変更し、その変数が値<value>に束縛
;;;   未束縛ならerror

;;; 外側の環境
(define (enclosing-environment env) (cdr env))
;;; 最近の環境
(define (first-frame env) (car env))
(define the-empty-environment '())
;;; 各フレームを <var-list> <value-list>の対とする
(define (make-frame variables values)
  (cons variables values))
(define (frame-variables frame) (car frame))
(define (frame-values frame) (cdr frame))
(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
;;; フレームを環境に接続
(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (meta-error "Too many arguments supplied" vars vals)
          (meta-error "Too few artuments supplied" vars vals))))
;;; フレームを外側へと探索 空の環境に達したら未束縛変数error
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (let ((val (car vals)))
               (if (eq? val '*unassigned*)
                   (meta-error "Unassigned variable" var)
                   val)))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (meta-error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (meta-error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; パッケージのインストール
(define (install-eval-package)
  ;; TODO:
  ;; デフォルトで遅延リストにするならquote式もそれに対応する必要あり?
  ;; quote----------------------------------------
  ;; (define (text-of-quotation exp env) 
  ;;   (if (list? (cadr exp))
  ;;       (meta-eval (make-lazy-list (cadr exp)) env)
  ;;       (cadr exp)))
  (define (text-of-quotation exp env)
    (cadr exp))
  (define (make-lazy-list lst)
    (if (null? lst)
        '()
        `(cons ',(car lst) ,(make-lazy-list (cdr lst)))))
  ;; set! 代入------------------------------------
  (define (eval-assignment exp env)
    (set-variable-value! (assignment-variable exp)
                         (meta-eval (assignment-value exp) env)
                         env)
    'ok)
  (define (assignment-variable exp) (cadr exp))
  (define (assignment-value exp) (caddr exp))
  ;; define 定義--------------------------------------
  (define (eval-difinition exp env)
    (define-variable! (definition-variable exp)
      (meta-eval (definition-value exp) env)
      env)
    'ok)
  ;; lambda--------------------------------
  (define (modify-parameters parameters)
    (if (list? parameters)
        (if (null? parameters) '()
            (cons (if (atom? (car parameters))
                      (list (car parameters) *default-evaluation-strategy*)
                      (car parameters))
                  (modify-parameters (cdr parameters))))
        (meta-error "Illegal form of lambda" parameters)))
  (define (lambda-parameters exp) (cadr exp))
  (define (lambda-body exp) (cddr exp))
  ;; if-------------------------------------
  (define (eval-if exp env)
    (cond ((> (length exp) 4) (meta-error "during expansion of (if ...) - too many arguments" exp))
          ((> 3 (length exp)) (meta-error "during expansion of (if ...) - too few arguments" exp))
          (else (if (actual-value (if-predicate exp) env)
                    (meta-eval (if-consequent exp) env)
                    (meta-eval (if-alternative exp) env))))) ;if節のエラー
  (define (if-predicate exp) (cadr exp))
  (define (if-consequent exp) (caddr exp))
  (define (if-alternative exp)
    (if (not (null? (cdddr exp)))
        (cadddr exp)
        '#f))
  (define (make-if predicate consequent alternative)
    (list 'if predicate consequent alternative))
  ;; begin-----------------------------------
  (define (begin-actions exp) (cdr exp))
  (define (sequence->exp seq)
    (cond ((null? seq) seq)
          ((last-exp? seq) (first-exp seq))
          (else (make-begin seq))))
  (define (make-begin seq) (cons 'begin seq))
  ;; cond------------------------------------
  (define (cond-clauses exp) (cdr exp))
  (define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))
  (define (cond-=>-clause? clause)
    (eq? (cadr clause) '=>))
  (define (cond-predicate clause) (car clause))
  (define (cond-actions clause) (cdr clause))
  (define (cond->if exp)
    (expand-clauses (cond-clauses exp)))
  (define (expand-clauses clauses)
    (if (null? clauses)
        #f
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (cond ((cond-else-clause? first)
                 (if (null? rest)
                     (sequence->exp (cond-actions first))
                     (meta-error "ELSE clause isn't last -- COND->IF"
                                 clauses)))
                ((cond-=>-clause? first)
                 (let ((pred (cond-predicate first))
                       (sym (gensym)))
                   (list 'let (list (list sym pred))
                         (list 'if  sym
                               (list (caddr first) sym)
                               (expand-clauses rest)))))
                (else (make-if (cond-predicate first)
                               (sequence->exp (cond-actions first))
                               (expand-clauses rest)))))))
  (put 'eval 'quote text-of-quotation)
  (put 'eval 'set! eval-assignment)
  (put 'eval 'define eval-difinition)
  (put 'eval 'lambda (lambda (exp env)
                       (if  (null? (lambda-body exp))
                            (meta-error "not enough arguments -- LAMBDA"
                                        exp)
                            (make-procedure (modify-parameters (lambda-parameters exp))
                                            (lambda-body exp)
                                            env))))
  (put 'eval 'if eval-if)
  (put 'eval 'begin (lambda (exp env)
                      (eval-sequence (begin-actions exp) env)))
  (put 'eval 'cond (lambda (exp env)
                     (meta-eval (cond->if exp) env)))
  (put 'eval 'quit (lambda (exp env)
                     (set! *quit* #t)))
  (put 'eval 'call-by (lambda (exp env)
                        (if (null? (cdr exp))
                            *default-evaluation-strategy*
                            (when (member (cadr exp) '(need value name))
                              (set! *default-evaluation-strategy* (cadr exp))))
                        ))  
  'done)

;;; 問題 4.4 and or のパッケージ
(define (install-and-or-package)
  (define (and-or-predicates exp)
    (cdr exp))
  (define (eval-and exp env)
    (let loop ((predicates (and-or-predicates exp)))
      (if (null? predicates) #t
          (let ((val (meta-eval (car predicates) env)))
            (if val
                (if (last-exp? predicates) val
                    (loop (cdr predicates)))
                #f)))))
  (define (eval-or exp env)
    (let loop ((predicates (and-or-predicates exp)))
      (if (null? predicates) #f
          (let ((val (meta-eval (car predicates) env)))
            (if val
                val
                (loop (cdr predicates)))))))
  (put 'eval 'and eval-and)
  (put 'eval 'or eval-or)
  'done)


;;; 問題 4.6 let
(define (install-let-package)
  (define (let-bindings exp)
    (cadr exp))
  (define (bindings->vars bindings)
    (map car bindings))
  (define (bindings->exps bindings)
    (map cadr bindings))
  (define (let-body exp)
    (cddr exp))
  (define (named-let-bindings exp)
    (caddr exp))
  (define (named-let-body exp)
    (cdddr exp))
  (define (named-let-name exp)
    (cadr exp))
  (define (let->combination exp)
    (if (symbol? (cadr exp))
        (let ((bindings (named-let-bindings exp))
              (name (named-let-name exp)))
          (cons 'begin
                (list (cons 'define 
                            (cons (cons name (bindings->vars bindings))
                                  (named-let-body exp)))
                      (cons name (bindings->exps bindings)))))
        (let ((bindings (let-bindings exp)))
          (append (list (append (list 'lambda (bindings->vars bindings))
                                (let-body exp)))
                  (bindings->exps bindings)))))
  (define (let*->nested-lets exp)
    (let ((bindings (let-bindings exp))
          (body (let-body exp)))
      (let loop ((vars (bindings->vars bindings))
                 (exps (bindings->exps bindings)))
        (cond ((null? vars) (append (list 'let '())
                                    body))
              (else (list 'let (list (list (car vars) (car exps)))
                          (loop (cdr vars) (cdr exps))))))))
  (put 'eval 'let (lambda (exp env)                    
                    (meta-eval (let->combination exp) env)))
  (put 'eval 'let* (lambda (exp env)
                     (meta-eval (let*->nested-lets exp) env)))
  'done)
;;; whileパッケージ
(define (install-loop-package)
  (define (while-predicate exp)
    (cadr exp))
  (define (while-body exp)
    (cddr exp))
  (define (while->let exp)
    (let ((test (while-predicate exp))
          (body (while-body exp)))
      `(let loop ()
         (if ,test
             (begin ,@body
                    (loop))))))  
  (put 'eval 'while (lambda (exp env)
                      (meta-eval (while->let exp) env)))
  'done)
;;; 問題 4.20 letrec
;; (letrec ((<var1> <exp1>) ... (<varn> <expn>))
;;   <body>)
;; (let ((<var1> '*unassigned*) ... (<varn> '*unassigned*))
;;   (set! <var1> <exp1>) ... (set! <varn> <expn>)
;;   <body>)
(define (install-letrec-package)
  (define (letrec-bindings exp)
    (cadr exp))
  (define (bindings->vars bindings)
    (map car bindings))
  (define (bindings->exps bindings)
    (map cadr bindings))
  (define (letrec-body exp)
    (cddr exp))
  (define (letrec->let exp)
    (let* ((bindings (letrec-bindings exp))
           (vars (bindings->vars bindings))
           (exps (bindings->exps bindings)))
      `(let ,(map (lambda (x) (list x ''*unassigned*)) vars)
         ,@(map (lambda (x y) (list 'set! x y)) vars exps)
         ,@(letrec-body exp))))  
  (put 'eval 'letrec (lambda (exp env)
                       (meta-eval (letrec->let exp) env)))
  'done)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 4.14 評価機をプログラムとして走らせる
(define (setup-environment)
  (set! *quit* #f)
  (set! *return* #f)
  (install-eval-package)
  (install-and-or-package)
  (install-loop-package)
  (install-let-package)
  (install-letrec-package)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! '#t #t initial-env)
    (define-variable! '#f #f initial-env)    
    initial-env))

(define *the-global-environment* (setup-environment))

(define (driver-loop)
  (call/cc (lambda (c) (set! *return* c)))
  (prompt-for-input *default-evaluation-strategy*)
  (let ((input (read)))
    (let ((output
           (actual-value input *the-global-environment*)))
      (cond (*quit* (set! *quit* #f) (user-print "Good bye!!\n"))
            ((unspecified-value? output) (driver-loop))
            (else (user-print output) (driver-loop))))))

(define (prompt-for-input string)
  (printf "scheme[~A]> " string))

(define (user-print object)  
  (if (compound-procedure? object)
      (pp `(λ ,(procedure-parameters object) 
             ,@(procedure-body object)))
      (begin (display object)
             (newline))))

